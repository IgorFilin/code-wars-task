// В этом ката вы напишете функцию, которая возвращает позиции
//  и значения «пиков» (или локальных максимумов) числового массива.

// Например, массив arr = [0, 1, 2, 5, 1, 0] имеет пик
//  в позиции 3 со значением 5 (поскольку arr[3] равен 5).

// Выходные данные будут возвращены в виде объекта с двумя свойствами: pos и Peaks.
// Оба этих свойства должны быть массивами. Если в данном массиве нет пика,
//  то на выходе должно быть {pos:[],peaks:[]}.

// Пример: PickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3])
//  должен возвращать {pos: [3, 7], Peaks: [6, 3]} ( или эквивалент на других языках)

// Все входные массивы будут действительными целочисленными массивами
//  (хотя они все равно могут быть пустыми),
// поэтому вам не нужно будет проверять ввод.

// Первый и последний элементы массива не будут считаться пиками
//  (в контексте математической функции мы не знаем, что находится после и до, и, следовательно,
//  мы не знаем, пик это или нет).

// Также остерегайтесь плато!!! [1, 2, 2, 2, 1] имеет пик,
//  а [1, 2, 2, 2, 3] и [1, 2, 2, 2,
// 2] нет. В случае пика плато возвращайте только положение
//  и значение начала плато. Например: PickPeaks([1, 2, 2, 2, 1])
//   возвращает {pos: [1], Peaks: [2]} (или эквивалент на других языках).

// Веселиться!

function pickPeaks(arr) {
  const result = { pos: [], peaks: [] };
  for (let i = 1; i < arr.length - 1; i++) {
    console.log(arr[arr.length - 1]);
    if (arr[i] > arr[i - 1] && arr[i] >= arr[i + 1]) {
      result.pos.push(i);
      result.peaks.push(arr[i]);
    }
    if (arr[0] > arr[1] || arr[arr.length - 1] >= arr[arr.length - 2]) {
      console.log(arr[arr.length - 1]);
      return { pos: [], peaks: [] };
    }
  }
  return result;
}

console.log(pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3]));

// https://www.codewars.com/kata/5279f6fe5ab7f447890006a7/train/javascript
