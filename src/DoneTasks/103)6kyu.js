// Ваша задача — написать функцию, которая делает именно то,
// что предполагает заголовок (поэтому, честное предупреждение, имейте в виду,
// что вы не выйдете из нее, просто бросив туда неубедительный метод сортировки)
// с массивом/списком/вектором целых чисел и ожидаемое количество nнаименьших возвращаемых
// элементов.

// Также:

// количество возвращаемых элементов не может превышать длину массива/списка/вектора;
// элементы можно дублировать;
// в случае дубликатов просто верните их в исходном порядке
// (для большей ясности см. третий пример).
// Те же примеры и многое другое в тестовых примерах:

// firstNSmallest([1,2,3,4,5],3) === [1,2,3] //well, not technically ===, but you get what I mean
// firstNSmallest([5,4,3,2,1],3) === [3,2,1]
// firstNSmallest([1,2,3,4,1],3) === [1,2,1]
// firstNSmallest([1,2,3,-4,0],3) === [1,-4,0]
// firstNSmallest([1,2,3,4,5],0) === []

function firstNSmallest(array, n) {
  //your code here
  const smallestElements = [...array].sort((a, b) => a - b).slice(0, n);
  const resultArray = [];
  array.forEach((el) => {
    if (smallestElements.includes(el) && resultArray.length < smallestElements.length) {
      resultArray.push(el);
    }
  });

  return resultArray;
}

console.log(firstNSmallest([3, -2, -3, 0, -2, 5, 5, -10, 8, 9, 6, -3, -3, 5, 7, -3, -7, -7, -9, -4, 6, 4, -6, 10, 2, 7, -6, -4, -2, -1, -1, 3, 10, 8, -10], 29));
// [3, -2, -3, 0, -2, 5, 5, -10, 6, -3, -3, 5, 7, -3, -7, -7, -9, -4, 6, 4, -6, 2, -6, -4, -2, -1, -1, 3, -10]
